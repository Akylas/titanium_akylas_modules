/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package akylas.charts2;

import java.lang.reflect.Field;
import java.text.DecimalFormat;
import java.util.HashMap;

import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.util.TiUIHelper;

import com.github.mikephil.charting.charts.ScatterChart;
import com.github.mikephil.charting.components.AxisBase;
import com.github.mikephil.charting.components.LimitLine.LimitLabelPosition;
import com.github.mikephil.charting.components.XAxis.XAxisPosition;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.components.Legend.LegendDirection;
import com.github.mikephil.charting.components.Legend.LegendForm;
import com.github.mikephil.charting.components.Legend.LegendPosition;
import com.github.mikephil.charting.components.YAxis.YAxisLabelPosition;
import com.github.mikephil.charting.data.Entry;
import com.github.mikephil.charting.data.LineDataSet.Mode;
import com.github.mikephil.charting.data.PieDataSet.ValuePosition;
import com.github.mikephil.charting.data.DataSet.Rounding;
import com.github.mikephil.charting.formatter.IAxisValueFormatter;
import com.github.mikephil.charting.formatter.IValueFormatter;
import com.github.mikephil.charting.utils.ColorTemplate;
import com.github.mikephil.charting.utils.Utils;
import com.github.mikephil.charting.utils.ViewPortHandler;

import android.graphics.DashPathEffect;
import android.graphics.Paint.Align;
import android.graphics.Paint.Cap;
import android.graphics.Paint.Join;

import org.appcelerator.kroll.common.APIMap;
import org.appcelerator.titanium.ProtectedModule;



@Kroll.module(name = "AkylasCharts2", id = "akylas.charts2")
public class Charts2Module extends ProtectedModule {
    // private static final String TAG = "AkylasCharts2Module";

    public Charts2Module() {
        super();
    }
    
    public abstract static class ValueFormatter implements IValueFormatter {
        public abstract String getFormattedValue(float value, Entry entry,
                int dataSetIndex, ViewPortHandler viewPortHandler);
    }
    
    public abstract static class AxisValueFormatter implements IAxisValueFormatter {
        public abstract String getFormattedValue(int index, float value,
                AxisBase axis);

        public int getDecimalDigits() {
            return -1;
        }
    }

    @Kroll.onAppCreate
    public static void onAppCreate(TiApplication app) {
        HashMap<String, String> map = new HashMap();
        map.put("Akylas.Charts2.LineChart",
                akylas.charts2.proxy.LineChartProxy.class.getName());
        map.put("Akylas.Charts2.BubbleChart",
                akylas.charts2.proxy.BubbleChartProxy.class.getName());
        map.put("Akylas.Charts2.ScatterChart",
                akylas.charts2.proxy.ScatterChartProxy.class.getName());
        map.put("Akylas.Charts2.CombinedChart",
                akylas.charts2.proxy.CombinedChartProxy.class.getName());
        map.put("Akylas.Charts2.BarChart",
                akylas.charts2.proxy.BarChartProxy.class.getName());
        map.put("Akylas.Charts2.HorizontalBarChart",
                akylas.charts2.proxy.HorizontalBarChartProxy.class.getName());
        map.put("Akylas.Charts2.CandleChart",
                akylas.charts2.proxy.CandleChartProxy.class.getName());
        map.put("Akylas.Charts2.RadarChart",
                akylas.charts2.proxy.RadarChartProxy.class.getName());
        map.put("Akylas.Charts2.PieChart",
                akylas.charts2.proxy.PieChartProxy.class.getName());
        map.put("Akylas.Charts2.LimitLine",
                akylas.charts2.proxy.LimitLineProxy.class.getName());
        APIMap.addMapping(map);
    }

    @Kroll.onVerifyModule
    public static void onVerifyModule(TiApplication app) {
        verifyPassword(app, "akylas.modules.key",
                AeSimpleSHA1.hexToString("7265745b496b2466553b486f736b7b4f"));
    }

    public static float[] getRawSizeArray(HashMap dict, String property,
            float[] defaultValue) {
        if (dict.containsKey(property)) {
            Object[] array = (Object[]) dict.get(property);
            float[] result = new float[array.length];
            for (int i = 0; i < array.length; i++) {
                result[i] = TiUIHelper.getRawSize(TiConvert.toString(array[i]),
                        null);
            }
            return result;
        } else {
            return defaultValue;
        }
    }

    public static DashPathEffect toDashPathEffect(Object value) {
        if (value instanceof HashMap) {
            HashMap dash = (HashMap) value;
            float[] pattern = getRawSizeArray(dash, "pattern",
                    new float[] { 10, 20 });
            float phase = TiConvert.toFloat(dash, "phase", 0.0f);
            DashPathEffect effect = new DashPathEffect(pattern, phase);
            return effect;
        }
        return null;
    }

    public static Cap toCap(Object value) {
        if (value instanceof String) {
            if (value == "square") {
                return Cap.SQUARE;
            } else if (value == "round") {
                return Cap.ROUND;
            } else {
                return Cap.BUTT;
            }
        } else {
            return Cap.values()[TiConvert.toInt(value)];
        }
    }

    public static Join toJoin(Object value) {
        if (value instanceof String) {
            if (value == "miter") {
                return Join.MITER;
            } else if (value == "round") {
                return Join.ROUND;
            } else {
                return Join.BEVEL;
            }
        } else {
            return Join.values()[TiConvert.toInt(value)];
        }
    }

    public static LimitLabelPosition toLabelPosition(Object value) {
        if (value instanceof String) {
            if (value == "left.bottom") {
                return LimitLabelPosition.LEFT_BOTTOM;
            } else if (value == "left.top") {
                return LimitLabelPosition.LEFT_TOP;
            }
            if (value == "right.bottom") {
                return LimitLabelPosition.RIGHT_BOTTOM;
            } else {
                return LimitLabelPosition.RIGHT_TOP;
            }
        } else {
            return LimitLabelPosition.values()[TiConvert.toInt(value)];
        }
    }

    public static XAxisPosition toXAxisLabelPosition(Object value) {
        if (value instanceof String) {
            if (value == "bottom") {
                return XAxisPosition.BOTTOM;
            } else if (value == "bottom.inside") {
                return XAxisPosition.BOTTOM_INSIDE;
            } else if (value == "top.inside") {
                return XAxisPosition.TOP_INSIDE;
            } else if (value == "both.sided") {
                return XAxisPosition.BOTH_SIDED;
            } else {
                return XAxisPosition.TOP;
            }
        } else {
            return XAxisPosition.values()[TiConvert.toInt(value)];
        }
    }

    public static YAxisLabelPosition toYAxisLabelPosition(Object value) {
        if (value instanceof String) {
            if (value == "inside") {
                return YAxisLabelPosition.INSIDE_CHART;
            } else {
                return YAxisLabelPosition.OUTSIDE_CHART;
            }
        } else {
            return YAxisLabelPosition.values()[TiConvert.toInt(value)];
        }
    }

    public static AxisValueFormatter axisFormatterValue(Object value,
            final KrollProxy theProxy) {
        if (value != null) {
            DecimalFormat format = null;
            if (value instanceof String) {
                format = new DecimalFormat((String) value);
            }
            if (value instanceof KrollFunction) {
                final KrollFunction labelFormatCallback = (KrollFunction) value;
                return new AxisValueFormatter() {

                    @Override
                    public String getFormattedValue(int index, float value,
                            AxisBase axis) {
                        Object result = labelFormatCallback
                                .call(theProxy.getKrollObject(), new Object[] {
                                        (Number) index, (Number) value });
                        return TiConvert.toString(result);
                    }

                    @Override
                    public int getDecimalDigits() {
                        return -1;
                    }
                };
            } else if (value instanceof HashMap) {
                HashMap dict = (HashMap) value;
                String pattern = TiConvert.toString(dict, "format", null);
                String patternPos = TiConvert.toString(dict, "positiveFormat",
                        null);
                String patternNeg = TiConvert.toString(dict, "negativeFormat",
                        null);

                String realpattern = pattern;
                if (patternPos != null && patternNeg != null)
                    realpattern = patternPos + ";" + patternNeg;
                else if (patternPos != null)
                    realpattern = patternPos + ";";
                else if (patternNeg != null)
                    realpattern = ";" + patternNeg;

                boolean hasSuffixOrPrefix = (dict.containsKey("suffix")
                        || dict.containsKey("prefix")
                        || dict.containsKey("negativePrefix")
                        || dict.containsKey("positivePrefix")
                        || dict.containsKey("positiveSuffix")
                        || dict.containsKey("negativeSuffix"));

                if (realpattern != null || hasSuffixOrPrefix) {
                    format = new DecimalFormat(
                            (realpattern != null) ? realpattern : "0.0");
                    String prefix = TiConvert.toString(dict, "prefix", "");
                    format.setNegativePrefix(
                            TiConvert.toString(dict, "negativePrefix", prefix));
                    format.setPositivePrefix(
                            TiConvert.toString(dict, "positivePrefix", prefix));
                    String suffix = TiConvert.toString(dict, "suffix", "");
                    format.setNegativeSuffix(
                            TiConvert.toString(dict, "negativeSuffix", suffix));
                    format.setPositiveSuffix(
                            TiConvert.toString(dict, "positiveSuffix", suffix));
                }
            }
            if (format != null) {
                final DecimalFormat theFormatter = format;
                return new AxisValueFormatter() {

                    @Override
                    public String getFormattedValue(int index, float value,
                            AxisBase axis) {
                        return theFormatter.format(value);
                    }

                    @Override
                    public int getDecimalDigits() {
                        return theFormatter.getMaximumFractionDigits();
                    }
                };
            }
        }
        return null;
    }

    public static IValueFormatter formatterValue(Object value,
            final KrollProxy theProxy) {
        if (value != null) {
            DecimalFormat format = null;
            if (value instanceof String) {
                format = new DecimalFormat((String) value);
            }
            if (value instanceof KrollFunction) {
                final KrollFunction labelFormatCallback = (KrollFunction) value;
                return new ValueFormatter() {
                    @Override
                    public String getFormattedValue(float value, Entry entry,
                            int dataSetIndex, ViewPortHandler viewPortHandler) {
                        Object result = labelFormatCallback.call(
                                theProxy.getKrollObject(),
                                new Object[] { (Number) value });
                        return TiConvert.toString(result);
                    }
                };
            } else if (value instanceof HashMap) {
                HashMap dict = (HashMap) value;
                String pattern = TiConvert.toString(dict, "format", null);
                String patternPos = TiConvert.toString(dict, "positiveFormat",
                        null);
                String patternNeg = TiConvert.toString(dict, "negativeFormat",
                        null);

                String realpattern = pattern;
                if (patternPos != null && patternNeg != null)
                    realpattern = patternPos + ";" + patternNeg;
                else if (patternPos != null)
                    realpattern = patternPos + ";";
                else if (patternNeg != null)
                    realpattern = ";" + patternNeg;

                boolean hasSuffixOrPrefix = (dict.containsKey("suffix")
                        || dict.containsKey("prefix")
                        || dict.containsKey("negativePrefix")
                        || dict.containsKey("positivePrefix")
                        || dict.containsKey("positiveSuffix")
                        || dict.containsKey("negativeSuffix"));

                if (realpattern != null || hasSuffixOrPrefix) {
                    format = new DecimalFormat(
                            (realpattern != null) ? realpattern : "0.0");
                    String prefix = TiConvert.toString(dict, "prefix", "");
                    format.setNegativePrefix(
                            TiConvert.toString(dict, "negativePrefix", prefix));
                    format.setPositivePrefix(
                            TiConvert.toString(dict, "positivePrefix", prefix));
                    String suffix = TiConvert.toString(dict, "suffix", "");
                    format.setNegativeSuffix(
                            TiConvert.toString(dict, "negativeSuffix", suffix));
                    format.setPositiveSuffix(
                            TiConvert.toString(dict, "positiveSuffix", suffix));
                }
            }
            if (format != null) {
                final DecimalFormat theFormatter = format;
                return new ValueFormatter() {

                    @Override
                    public String getFormattedValue(float value, Entry entry,
                            int dataSetIndex, ViewPortHandler viewPortHandler) {
                        return theFormatter.format(value);
                    }
                };
            }
        }
        return null;
    }

    public static Align toTextAlign(Object value) {
        if (value instanceof String) {
            if (value == "right") {
                return Align.RIGHT;
            } else if (value == "middle" || value == "center") {
                return Align.CENTER;
            } else {
                return Align.LEFT;
            }
        } else {
            return Align.values()[TiConvert.toInt(value)];
        }
    }

    public static YAxis.AxisDependency toAxisDependency(Object value) {
        if (value instanceof String) {
            if (value == "right") {
                return YAxis.AxisDependency.RIGHT;
            } else {
                return YAxis.AxisDependency.LEFT;
            }
        } else {
            return YAxis.AxisDependency.values()[TiConvert.toInt(value)];
        }
    }

    public static ValuePosition toValuePosition(Object value) {
        if (value instanceof String) {
            if (value == "outside") {
                return ValuePosition.OUTSIDE_SLICE;
            } else {
                return ValuePosition.INSIDE_SLICE;
            }
        } else {
            return ValuePosition.values()[TiConvert.toInt(value)];
        }
    }

    public static ScatterChart.ScatterShape toScatterShape(Object value) {
        if (value instanceof String) {
            if (value == "chevron.down") {
                return ScatterChart.ScatterShape.CHEVRON_DOWN;
            } else if (value == "chevron.up") {
                return ScatterChart.ScatterShape.CHEVRON_UP;
            } else if (value == "circle") {
                return ScatterChart.ScatterShape.CIRCLE;
            } else if (value == "cross") {
                return ScatterChart.ScatterShape.CROSS;
            } else if (value == "triangle") {
                return ScatterChart.ScatterShape.TRIANGLE;
            } else if (value == "x") {
                return ScatterChart.ScatterShape.X;
            } else {
                return ScatterChart.ScatterShape.SQUARE;
            }
        } else {
            return ScatterChart.ScatterShape.values()[TiConvert.toInt(value)];
        }
    }

    public static Rounding toRounding(Object value) {
        if (value instanceof String) {
            if (value == "up") {
                return Rounding.UP;
            } else if (value == "down") {
                return Rounding.DOWN;
            } else {
                return Rounding.CLOSEST;
            }
        } else {
            return Rounding.values()[TiConvert.toInt(value)];
        }
    }

    public static Mode toMode(Object value) {
        if (value instanceof String) {
            if (value == "cubic") {
                return Mode.CUBIC_BEZIER;
            } else if (value == "stepped") {
                return Mode.STEPPED;
            } else if (value == "horizontal") {
                return Mode.HORIZONTAL_BEZIER;
            } else {
                return Mode.LINEAR;
            }
        } else {
            return Mode.values()[TiConvert.toInt(value)];
        }
    }

    public static int[] colorsArrayValue(Object value) {
        if (value instanceof String) {
            String propName = ((String) value).toUpperCase() + "_COLORS";
            Field f;
            try {
                f = ColorTemplate.class.getDeclaredField(propName);
                if (f != null) {
                    Object result = f.get(null);
                    if (result instanceof int[]) {
                        return (int[]) result;
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
        } else if (value instanceof Object[]) {
            Object[] inArray = (Object[]) value;
            int[] outArray = new int[inArray.length];
            for (int i = 0; i < inArray.length; i++) {
                outArray[i] = TiConvert.toColor(inArray[i]);
            }
            return outArray;
        }
        return null;
    }

    public static LegendDirection toLegendDirection(Object value) {
        if (value instanceof String) {
            if (value == "left.to.right") {
                return LegendDirection.RIGHT_TO_LEFT;
            } else {
                return LegendDirection.LEFT_TO_RIGHT;
            }
        } else {
            return LegendDirection.values()[TiConvert.toInt(value)];
        }
    }

    public static LegendPosition toLegendPosition(Object value) {
        if (value instanceof String) {
            switch ((String) value) {
            case "left":
                return LegendPosition.LEFT_OF_CHART;
            case "left.center":
                return LegendPosition.LEFT_OF_CHART_CENTER;
            case "left.inside":
                return LegendPosition.LEFT_OF_CHART_INSIDE;
            case "right":
                return LegendPosition.RIGHT_OF_CHART;
            case "right.center":
                return LegendPosition.RIGHT_OF_CHART_CENTER;
            case "right.inside":
                return LegendPosition.RIGHT_OF_CHART_INSIDE;
            case "above.left":
                return LegendPosition.ABOVE_CHART_LEFT;
            case "above.center":
                return LegendPosition.ABOVE_CHART_CENTER;
            case "above.right":
                return LegendPosition.ABOVE_CHART_RIGHT;
            case "below.center":
                return LegendPosition.BELOW_CHART_CENTER;
            case "below.right":
                return LegendPosition.BELOW_CHART_RIGHT;
            case "pie.center":
                return LegendPosition.PIECHART_CENTER;
            default:
                return LegendPosition.BELOW_CHART_LEFT;
            }

        } else {
            return LegendPosition.values()[TiConvert.toInt(value)];
        }
    }
    
    public static LegendForm toLegendForm(Object value) {
        if (value instanceof String) {
            switch ((String) value) {
            case "circle":
                return LegendForm.CIRCLE;
            case "line":
                return LegendForm.LINE;
            default:
                return LegendForm.SQUARE;
            }

        } else {
            return LegendForm.values()[TiConvert.toInt(value)];
        }
    }
    
    public static float getInDp(Object value) {
        return Utils.convertPixelsToDp(TiUIHelper.getInPixels(value));
    }
}
