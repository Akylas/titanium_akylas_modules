//
//  TritonPlayer.h
//  TritonPlayer
//
//  Copyright 2014 Triton Digital. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <CoreLocation/CoreLocation.h>
#import <AudioToolbox/AudioQueue.h>

// Settings dictionary keys

extern NSString *const SettingsEnableLocationTrackingKey;
extern NSString *const SettingsStationNameKey;
extern NSString *const SettingsMountKey;
extern NSString *const SettingsContentURLKey;
extern NSString *const SettingsAppNameKey;
extern NSString *const SettingsBroadcasterKey;
extern NSString *const SettingsStreamParamsExtraKey;

extern NSString *const TritonPlayerDomain;

/// Errors generated by TritonPlayer
typedef NS_ENUM(NSInteger, TDPlayerError) {
    
    /// The specified mount doesnâ€™t exist
    TDPlayerMountNotFoundError = 3000,
    
    /// The mount is geoblocked
    TDPlayerMountGeoblockedError = 3001,
    
    /// A required parameter is missing or an invalid parameter was sent
    TDPlayerMountBadRequestError = 3002,
    
    /// The version of the provisioning doesn't exist
    TDPlayerMountNotImplemntedError = 3003,
    
    /// The host doesn't exist
    TDPlayerHostNotFoundError = 3004
};

/// States representing Triton Player playback life-cycle
typedef NS_ENUM(NSInteger, TDPlayerState) {
    
    /// Player is stopped. The playhead position returns to the beginning.
    kTDPlayerStateStopped,
    
    /// Player is currently playing
    kTDPlayerStatePlaying,
    
    /// Player is connecting to the stream
    kTDPlayerStateConnecting,
    
    /// Player is paused. The playhead position is kept at the last position. Not available for live streams.
    kTDPlayerStatePaused,
    
    /// Player is on error state
    kTDPlayerStateError,
    
    /// The end of the media has been reached. Not available for live streams.
    kTDPlayerStateCompleted
};

typedef NS_ENUM(NSInteger, TDPlayerInfo) {
    /// The player established connection with the stream. It will soon start playing.
    kTDPlayerInfoConnectedToStream,
    
    /// The stream is buffering. The buffer percentage can be queried by the key InfoBufferingPercentageKey in the extra dictionary for player:didReceiveInfo:andExtra:
    kTDPlayerInfoBuffering,
    
    /// The provided mount is geoblocked. The player was redirected to an alternate mount. It's mount name can be obtained by the key InfoAlternateMountNameKey in the extra dictionary.
    kTDPlayerInfoForwardedToAlternateMount
};

extern NSString *const InfoBufferingPercentageKey;
extern NSString *const InfoAlternateMountNameKey;

@class CuePointEvent;
@class TritonPlayer;

/**
 * TritonPlayerDelegate defines methods you can implement to handle streaming state notifications and to receive cue point events.
 */
@protocol TritonPlayerDelegate<NSObject>

@required

/// @name Handling state changes

/**
 * Called when the player's state changed.
 *
 * @param player The player whose state changed
 * @param state The new state of the player
 */

- (void) player:(TritonPlayer *) player didChangeState:(TDPlayerState) state;

@optional

/// @name Receiving player info

/**
 * Called when the player's state changed.
 *
 * @param player The player whose state changed
 * @param state The new state of the player
 */

- (void) player:(TritonPlayer *) player didReceiveInfo:(TDPlayerInfo) info andExtra:(NSDictionary *) extra;

/// @name Handling cue point events

/**
 * Called when there's a Cue Point available to be processed. A NSDictionary is passed containing the Cue Point metadata. All the available keys are defined in CuePointEvent.h.
 * See STWCue_Metadata_Dictionary.pdf for more details on the available cue point information.
 *
 * @param player The player which is receiving cue point events
 * @param cuePointEvent A CuePointEvent object containing all cue point information.
 */

- (void)player:(TritonPlayer *) player didReceiveCuePointEvent:(CuePointEvent *)cuePointEvent;

/// @name Handling interruptions

/**
 * Notifies that an audio interruption is about to start (alarm, phone call, etc.). The application has the opportunity to take the proper actions: stop the player, lower the volume, etc.
 *
 * @param player The TritonPlayer object which is being interrupted.
 */

- (void)playerBeginInterruption:(TritonPlayer *) player;

/**
 * Notifies about a finished interruption. It's the proper moment to resume the player, raise the volume, etc.
 *
 * @param player The TritonPlayer object whose interruption is ending.
 */

- (void)playerEndInterruption:(TritonPlayer *) player;

@end

/** 
 * TritonPlayer handles the playback of stations provided by Triton Digital. It also supports receiving CuePoint events with metadata for track information, ads etc.
 */

@interface TritonPlayer : NSObject

/// @name Querying player information

/**
 * The current state of the player
 */

@property (readonly) TDPlayerState state;

/**
 * Returns the current playback duration in seconds. Not available for live streams.
 */

@property (readonly) NSTimeInterval playbackDuration;

/**
 * Returns the current playback position in seconds.
 */

@property (readonly) NSTimeInterval currentPlaybackTime;

/**
 * Tells whether the player is streaming audio.
 */

@property (readonly) BOOL isExecuting;

/**
 * When the player's state is kTDPlayerStateError, this property contains the associated error. It's nil for all other states.
 */

@property (readonly) NSError *error;

/**
 * The underlying audio queue which playbacks the audio. Use this when you need to process or analyze the audio data. Ex. When building a spectrum analyzer.
 *
 * @returns The underlying AudioQueue
 */

- (AudioQueueRef)getAudioQueue;

/**
 * Returns the current library version
 *
 * @return A string containing the current library version.
 */

- (NSString *)getLibVersion;

/**
 * Informs if the network is available.
 *
 * @return Whether the network is available.
 */

- (BOOL)isNetworkReachable;


/// @name Location targeting

/**
 * The most recent user location available for audience targeting.
 */

@property (readonly) CLLocation *targetingLocation;

/// @name Handling interruptions

/**
 * When an interruption ends (phone call, alarm, siri etc.) this flags will be true when it is appropriate to resume playback without waiting for user input.
 *
 * If the user ignored a call, it means that he/she wants to continue listening to the app and the flag will be YES. On the other side, if the interruption was caused by the Music app or other audio app being executed,
 * it means that he/should explicitly play again to continue listening to the stream and the flag will retur NO.
 */

@property (readonly) BOOL shouldResumePlaybackAfterInterruption;

/// @name Creating a TritonPlayer

/** 
 * Instantiate a new player using the specified settings
 *
 * @param inDelegate The delegate for handling stream callbacks and CuePoint events
 * @param settings A NSDictionary containing station parameters.
 */

- (id)initWithDelegate:(id<TritonPlayerDelegate>)inDelegate andSettings:(NSDictionary *) settings;

/// @name Updating player settings

/** 
 * Update player settings. All the information passed overrides the current settings and will take effect the next time the play method is called.
 *
 * When changing to a new station, this method must be called before calling play on the new station.
 *
 * @param settings A NSDictionary containing station parameters.
 */

- (void)updateSettings:(NSDictionary *) settings;

/// @name Reproduction flow

/** 
 * Plays the current stream with the configuration from the settings dictionary.
 *
 * @see updateSettings:
 */

- (void)play;

/** 
 * Stops the current stream
 */

- (void)stop;

/**
 * Pauses the current stream. In case of a live stream, it's the same as calling stop.
 */

- (void)pause;

/**
 * Moves the cursor to the specified time interval. Only works if the media is seekable.
 */

- (void)seekToTimeInterval:(NSTimeInterval) interval;

/// @name Controlling the volume

/**
 * Mute current playing audio
 */

- (void)mute;

/**
 * Unumte current playing audio
 */

- (void)unmute;

/**
 * Set volume of current playing audio
 *
 * @param volume a float between 0-1.
 */

- (void)setVolume:(float)volume;

@end
